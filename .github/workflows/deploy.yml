# .github/workflows/deploy.yml
name: Deploy ideal_next_js

on:
  push:
    branches: [ new-ver ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-north-1
  ROLE_ARN: arn:aws:iam::551829622535:role/githubrepoIdealtax
  SUBDIR: nextjs-clone
  APP_NAME: ideal_next_js
  DEPLOY_TAG_KEY: Deploy
  DEPLOY_TAG_VAL: Yes

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # Find EC2 instances with Deploy=Yes and confirm SSM sees them
      - name: Discover instance(s) by tag and confirm SSM
        id: discover
        run: |
          set -euo pipefail
          echo "Region: ${AWS_REGION}"
          echo "Tag: ${DEPLOY_TAG_KEY}=${DEPLOY_TAG_VAL}"

          IDS=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters "Name=tag:${DEPLOY_TAG_KEY},Values=${DEPLOY_TAG_VAL}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text)

          echo "EC2 IDs: ${IDS:-<none>}"

          if [ -n "${IDS}" ]; then
            echo "SSM-managed nodes among those IDs:"
            aws ssm describe-instance-information \
              --region "${AWS_REGION}" \
              --filters "Key=InstanceIds,Values=${IDS}" \
              --query 'InstanceInformationList[].{Id:InstanceId,Ping:PingStatus,Tags:Tags}' \
              --output table
            # Keep only SSM-managed IDs (Ping online/offline both okay for targeting)
            SSM_IDS=$(aws ssm describe-instance-information \
              --region "${AWS_REGION}" \
              --filters "Key=InstanceIds,Values=${IDS}" \
              --query 'InstanceInformationList[].InstanceId' \
              --output text)
          else
            SSM_IDS=""
          fi

          echo "SSM IDs: ${SSM_IDS:-<none>}"
          echo "ids=${SSM_IDS}" >> "$GITHUB_OUTPUT"

          if [ -z "${SSM_IDS}" ]; then
            echo "::error::No SSM-managed instances found for tag ${DEPLOY_TAG_KEY}=${DEPLOY_TAG_VAL} in ${AWS_REGION}."
            exit 1
          fi

      # Send the deploy script to those instances via SSM
      - name: Send SSM deploy command
        id: send_cmd
        env: 
          INST_IDS: ${{ steps.discover.outputs.ids }}
        run: |
          set -euo pipefail
          echo "Target instance IDs: ${INST_IDS}"

          # Build the remote script as JSON (safe quoting)
          CMD_JSON=$(jq -Rs . <<'BASH'
          #!/usr/bin/env bash
          set -Eeuo pipefail

          REPO_URL="https://github.com/kareou/ideal_next_js"
          BRANCH="new-ver"
          SUBDIR="nextjs-clone"
          APP_ROOT="/srv/ideal_next_js"
          SERVICE_NAME="ideal_next_js"
          PORT="${PORT:-3000}"
          APP_USER="ubuntu"

          sudo mkdir -p "$APP_ROOT"
          sudo chown -R "$APP_USER":"$APP_USER" "$APP_ROOT"
          cd "$APP_ROOT"

          # Install Node.js and Git
          curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
          sudo apt-get update
          sudo apt-get install -y nodejs git

          # Checkout/update code
          if [ ! -d .git ]; then
            sudo -u "$APP_USER" git clone "$REPO_URL" .
          fi
          sudo -u "$APP_USER" git fetch --all
          sudo -u "$APP_USER" git checkout "$BRANCH"
          sudo -u "$APP_USER" git reset --hard "origin/$BRANCH"

          cd "$APP_ROOT/$SUBDIR"

          # Install dependencies and build
          sudo -u "$APP_USER" npm ci
          sudo -u "$APP_USER" npm run build

          # (Optional) Prisma
          # sudo -u "$APP_USER" npx prisma generate || true
          # sudo -u "$APP_USER" npx prisma migrate deploy || true

          # Create/refresh systemd unit
          SERVICE_PATH="/etc/systemd/system/${SERVICE_NAME}.service"
          sudo tee "$SERVICE_PATH" >/dev/null <<EOF
          [Unit]
          Description=${SERVICE_NAME} Next.js service
          After=network.target

          [Service]
          Type=simple
          User=${APP_USER}
          WorkingDirectory=${APP_ROOT}/${SUBDIR}
          Environment=NODE_ENV=production
          Environment=PORT=${PORT}
          Environment=PATH=/usr/local/bin:/usr/bin:/bin
          ExecStart=/usr/bin/npm run start
          Restart=always
          RestartSec=5

          [Install]
          WantedBy=multi-user.target
          EOF

          sudo systemctl daemon-reload
          sudo systemctl enable "${SERVICE_NAME}"
          sudo systemctl restart "${SERVICE_NAME}"
          sudo systemctl status "${SERVICE_NAME}" --no-pager
          BASH
          )

          CMD_ID=$(aws ssm send-command \
              --region "${AWS_REGION}" \
              --document-name "AWS-RunShellScript" \
              --instance-ids ${INST_IDS} \
              --comment "Deploy ${APP_NAME}" \
              --parameters "commands=[$CMD_JSON]" \
              --query Command.CommandId --output text)

          echo "CommandId: $CMD_ID"
          echo "command_id=$CMD_ID" >> "$GITHUB_OUTPUT"

      # Robust waiter: prints stdout/stderr and fails on non-success
      - name: Wait for SSM command to complete & print output
        env:
          REGION: ${{ env.AWS_REGION }}
          INST_IDS: ${{ steps.discover.outputs.ids }}
          CMD_ID: ${{ steps.send_cmd.outputs.command_id }}
        run: |
          set -Eeuo pipefail
          echo "CMD_ID=${CMD_ID}"
          echo "INST_IDS=${INST_IDS}"

          # Only handle the first instance id for output (extend to loop if you target many)
          INST_ID=$(echo "${INST_IDS}" | awk '{print $1}')
          echo "Inspecting instance: ${INST_ID}"

          sleep 5

          for i in $(seq 1 720); do
            OUT=$(aws ssm get-command-invocation \
              --region "$REGION" \
              --command-id "$CMD_ID" \
              --instance-id "$INST_ID" 2>&1 || true)

            if echo "$OUT" | grep -q 'InvocationDoesNotExist'; then
              echo "Status: not-ready (InvocationDoesNotExist)"
              sleep 5
              continue
            fi

            STATUS=$(echo "$OUT" | jq -r '.Status // empty')
            if [ -z "$STATUS" ]; then
              echo "Raw response:"
              echo "$OUT"
              sleep 5
              continue
            fi

            echo "Status: $STATUS"
            if [ "$STATUS" = "Pending" ] || [ "$STATUS" = "InProgress" ]; then
              sleep 5
              continue
            fi

            # Terminal state: print outputs
            echo "$OUT" | jq '{Status, StandardOutputContent, StandardErrorContent}'
            test "$STATUS" = "Success"
            exit 0
          done

          echo "::error::Timed out waiting for SSM command to complete."
          echo "Command summary:"
          aws ssm list-commands --region "$REGION" --command-id "$CMD_ID" --output table || true
          echo "Invocations:"
          aws ssm list-command-invocations --region "$REGION" --command-id "$CMD_ID" --details --output table || true
          exit 1
